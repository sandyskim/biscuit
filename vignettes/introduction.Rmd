---
title: "Introduction to biscuit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Installation

`biscuit` is an R package that utilizes a Bayesian hierarchical inference model to analyze high-throughput CRISPR screen data. It performs inference using Stan via the `cmdstanr` interface.

To install `cmdstanr` (and `cmdstan`):

```{rf}
# we recommend running this in a fresh R session or restarting your current session
install.packages("cmdstanr", repos = c('https://stan-dev.r-universe.dev', getOption("repos")))

library(cmdstanr)
install_cmdstan(cores = 2) # number of cores to use for installation
```

To install `biscuit`:

```{r}
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}

remotes::install_github("sandyskim/biscuit")
library(biscuit)
```

## Using `biscuit`

The `biscuit` workflow:

1.  **Load and bundle data into a `dough` object**\
    Organize raw counts, guide-to-gene mapping, and sample design into a single structured object.

2.  **Filter and preprocess the `dough` object**\
    Remove low-count guides and genes with few guides.

3.  **Fit the `biscuit` model**\
    Apply the hierarchical Bayesian model to infer guide- and gene-level effects.

4.  **Explore posterior estimates**\
    After fitting the model, summarize the guide- and gene-level posterior distributions, which provide both effect size estimates and uncertainty, and significant hits. Additionally, `biscuit` provides plotting functions to visualize these results.

To demonstrate how to use `biscuit`, we provide an example using the data from Regnase-1 screen [1].

### Load and bundle data into a `dough` object

First, load in the data from the Regnase-1 screen:

```{r}
data(regnase)
```

To create a `dough` object, you need:

-   **Raw sequencing counts**: a matrix or data frame with `n_guides` rows and `n_samples` columns.
-   **Guide-to-gene mapping**: a matrix or data frame with `n_guides` rows and two columns, containing the guide names and corresponding gene names.
-   **Sample-to-condition mapping**: a matrix or data frame with `n_guides` rows and two columns, containing the sample names, which match the column names of the counts, and the corresponding experimental condition. There must be exactly two conditions, e.g., *control* and *treatment*, with the first sample being a control sample.
-   *(Optional)* **Non-targeting controls**: a list of guide names corresponding to non-targeting controls. If your screen includes non-targeting controls, we strongly recommend including them, as they improve inference.

To make a `dough` object, we call the function `make_dough()`:

```{r}
dough_obj <- make_dough(
  counts = regnase$counts,
  guide_to_gene = regnase$guide_to_gene,
  sample_design = regnase$sample_design,
  controls = regnase$controls
)
```

`make_dough()` returns a `dough` object with `$data`, which contains the input data (counts, guide-to-gene mapping, sample design, and if applicable, names of the non-targeting controls), to prepare for quality control, model fitting and eventual downstream analysis.

### Filter and preprocess the `dough` object

Now that the data is organized in a `dough` object, we can filter the data before fitting the model.

`biscuit` performs the following preprocessing steps:

1.  **Removing low-count guides**: guides with very few reads across all samples may not provide reliable information. By default, all guides with 0 counts across all samples and guides with a sum of \<1 count across 20% of samples are filtered out.
2.  **Filtering genes with few guides**: genes targeted by only one or two guides can be noisy. By default, genes with \<2 guides targeting it are filtered out.

To preprocess the data, we call the function `trim_dough()`:

```{r}
dough_obj <- trim_dough(
  dough_obj,
  min_per_sample = 1, 
  min_prop = 0.2, 
  min_guides_per_gene = 2, 
  verbose = TRUE
)
```

Filtering can also be done while fitting the `biscuit` model.

### Fit the `biscuit` model

Once the `dough` object is prepared, it is ready to fit the model.

First, we specify the directory in which the posterior samples (`posterior.Rdata`) and sampling logs (`biscuit.log`) will be saved:

```{r}
output_dir <- getwd() # edit to your preferred directory
```

To fit the model, we call the function `bake_biscuit()`. `biscuit` uses a Bayesian hierarchical model to infer guide-level and gene-level effects from CRISPR screen data.

Note: `biscuit` performs statistical inference using MCMC sampling, which can be computationally intensive. Depending on your computational resources, fitting the model on this data set may take *up to an hour or more*.

```{r}
biscuit_fit <- bake_biscuit(
  dough_obj,
  output_dir,
  filter = FALSE,
  save_samples = TRUE,
  n_parallel_chains = 4,
  seed=13,
  pseudocount=TRUE)
```

Once the model is finished fitting, `biscuit_fit()` converts the original `dough` object into a `biscuit` object, which contains the original input data from `dough$data` under `$data` and the posterior samples, sampling diagnostics, and sampling run time under `$fit`.

### Explore posterior estimates

`biscuit` computes posterior summaries as well as the local false sign rate for each guide-level and gene-level effect for downstream analysis.

#### Summarizing posterior estimates

`biscuit` computes a summary table of the posterior for the modelâ€™s parameters of interest:

-   `mu`: gene-level effects
-   `beta1`: guide-level effects
-   `beta0`: baseline guide-level expression (intercept)
-   `phi`: guide-level dispersion
-   `gamma`: sample-level dispersion scaling factors

For each parameter, the summary table reports the **mean**, **median**, **standard deviation**, and **2.5% and 97.5% quantiles**. In addition, the **local false sign rate** is calculated for `beta1` and `mu`, providing a measure of significance as a function of directional confidence.

To summarize posterior draws and calculate local false sign rate, we call the function `summarize_parameters()`:

```{r}
biscuit_fit <- summarize_parameters(biscuit_fit)

# view the summary of beta1 (guide-level effects)
head(biscuit_fit$results$beta1)

# view the summary of mu (gene-level effects)
head(biscuit_fit$results$mu)
```

After posterior draws are summarized, the `biscuit` object stores the summaries under `$results`.

#### Visualizing results

After `biscuit` summarizes the posterior draws for the parameters of interest, `biscuit` provides a few plotting functions to visualize results.

`plot_guide_violin()` shows the distribution of the posterior mean effects for each guide (`beta1`), if applicable, stratified by targeting and non-targeting guides, as violin plots, highlighting the spread. This plot allows us to see variability of the inferred guide-level effects (`beta1`), uncovering potentially problematic guides. By stratifying targeting and non-targeting guides, we can inspect whether the model is capturing effects sufficiently and ensure non-targeting guides have little to no effect, exhibiting centering around zero with little variance.

```{r}
plot_guide_violin(biscuit_fit)
```

`plot_guide_ma()` visualizes the guides' average effects against its deviation from the mean. This allows us to identify any biases or trends in the posterior at the guide-level; in particular, outlier guides with strong deviations that can influence the gene-level inferred effect `mu`.

```{r}
plot_guide_ma(biscuit_fit)
```

`plot_gene_rank()` orders genes by their inferred effect size (`mu)` in descending order, visualizing the ranking and identifying the most significant hits. Since inferred gene effects are ordered, this allows us to identify the strongest hits via magnitude, while comparing them in relation to the rest of the genes in the screen.

```{r}
plot_gene_rank(biscuit_fit)
```

`plot_gene_volcano()` visualizes genes via their inferred effect size (`mu`) against their statistical significance. This allows us to assess of gene essentiality across the full distribution: significant hits appearing in the upper corners and non-significant genes clustering near the center and bottom. Combining magnitude and confidence allows us to prioritize the strongest hits and identify potential noise.

```{r}
plot_gene_volcano(biscuit_fit)
```

`plot_phi_gamma_density()` shows posterior means of guide-level dispersion (`phi`) and how sample-level scaling (\`gamma\`) varies across samples. By stacking the densities of `phi` and how each `gamma` scales `phi`, we can inspect difference in dispersion across samples and evaluate whether it aligns with the expectation that control samples exhibit lower dispersion compared to treatment samples.

```{r}
plot_phi_gamma_density(biscuit_fit)
```

`plot_mu_beta1` visualizes, for a given gene, the posterior distribution of the gene-level effect (`mu`) and the posterior means of guide-level effects (`beta1`) for all guides targeting that gene, showing how individual guides contribute to the overall gene effect. This allows us to assess guide behavior and identify any guide outliers as a function of the gene its targeting.

```{r}
plot_mu_beta1(biscuit_fit, 'Zc3h12a')
```

## Conclusion

`biscuit` provides a robust workflow for analysis of CRISPR screens, combining Bayesian inference and intuitive visualizations to identify significant hits and quantify uncertainty at both the gene and guide levels.

## References

[1] Wei J, Long L, Zheng W, Dhungana Y, Lim SA, Guy C, Wang Y, Wang Y-D, Qian C, Xu B, et al.\
*Targeting REGNASE-1 programs long-lived effector T cells for cancer therapy.*\
Nature. 2019;576(7787):471-476. <doi:10.1038/s41586-019-1821-z>
